#include <stdio.h>
#include <stdlib.h>



// проверка включения последовательности в 'словарь'
int stc_in_dict (const unsigned char *str, unsigned char ch, unsigned char **dict, unsigned int dict_len, unsigned int str_len) {
    // строкой названа последовательность байтов
    if (str_len == 0) {return 1;}
    for (unsigned int i = 256; i < dict_len; ++i) {
        for (unsigned int j = 0; j <= str_len; ++j) {
            if (dict[i][0] == (str_len + 1)) {
                // совпало
                if (j == str_len && ch == dict[i][j+1]) {
                    return 1;
                }
                // очевидно различны
                if (str[j] != dict[i][j+1]) {
                    break;
                }
            }
        }
    }
    return 0;
}

unsigned int get_dict(unsigned char **dict, unsigned int dict_len, unsigned char *str, unsigned int str_len) {
    if (str_len == 1) {return str[0];}
    for (unsigned int i = 256; i < dict_len; ++i) {
        for (unsigned int j = 0; j < str_len; ++j) {
            if (dict[i][0] == str_len) {
                // очевидно различны
                if (str[j] != dict[i][j+1]) {
                    break;
                }
                // совпало
                if ((j+1) == str_len) {
                    return i;
                }
            }
        }
    }
    return 0;
}


// lzw для байтовых последовательностей (сжатие)
// преобразование списка байтов в список некоторых 'чисел'
unsigned int *lzw_encode(unsigned char *input, size_t size_inp, unsigned long long int *result_len) {
    // словарь состоит из длины (пока что первый байт) и самой последовательности далее
    unsigned int len_key = 0; unsigned int key_mem_step = 4096; unsigned int mem_for_key = 4096;
    unsigned char *key = malloc(sizeof(char ) * mem_for_key); // определение 'строки'-ключа

    unsigned int dict_len = 256; unsigned int dict_mem_step = 4096; unsigned int mem_for_dict = 4096;
    unsigned char **dict = malloc(sizeof(unsigned char *) * mem_for_dict); // определение 'словаря'
    // заполнение словаря всевозможными значениями
    for (int i = 0; i < 256; ++i) { dict[i] = malloc(sizeof(char ) * 2) ; dict[i][0] = 1; dict[i][1] = (char )i;}

    // результат (непонятно сколько памяти держать под каждое значение (типа тип инта))
    unsigned int res_len = 0; unsigned int res_mem_step = 4096; unsigned int mem_for_res = 4096;
    unsigned int *res = malloc(sizeof(unsigned int) * mem_for_res); // сжатая последовательность

    for (unsigned int inp_byte = 0; inp_byte < size_inp; ++inp_byte) { // проход по байтам 'input'
        if (stc_in_dict(key, input[inp_byte], dict, dict_len, len_key) == 1) { // (w+c) in dict
            if ((len_key + 1) > mem_for_key) { // память под ключ кончилась
                mem_for_key = mem_for_key + key_mem_step;
                key = realloc(key, mem_for_key * sizeof(char ));
                if (key == NULL) {
                    fprintf(stderr, "Memory allocation error\n");
                    exit(1);
                }
            }
            // key = key + input[inp_byte]
            key[len_key] = input[inp_byte];
            ++len_key;
        } else {
            if ((dict_len + 1) > mem_for_dict) { // память под словарь кончилась
                mem_for_dict = mem_for_dict + dict_mem_step;
                dict = (unsigned char **) realloc(dict, mem_for_dict * sizeof(unsigned char *));
//                printf("dict: %d\n", mem_for_dict);
                if (dict == NULL) {
                    fprintf(stderr, "Memory allocation error\n");
                    exit(1);
                }
            }
            if ((res_len + 1) > mem_for_res) { // память под результат кончилась
                mem_for_res = mem_for_res + res_mem_step;
                res = realloc(res, mem_for_res * sizeof(unsigned int));
                if (res == NULL) {
                    fprintf(stderr, "Memory allocation error\n");
                    exit(1);
                }
            }
            // result.append(dictionary[w])
            res[res_len] = get_dict(dict, dict_len, key, len_key);
            if (res[res_len] > 65536) {printf("ok\n"); exit(1);} // хватит два байта
            ++res_len;
            // dict[dict_len] = (key+input[inp_byte])
            dict[dict_len] = malloc(sizeof(char ) * (len_key + 2));
            for (unsigned int i = 0; i < len_key; ++i) {dict[dict_len][i+1] = key[i];}
            dict[dict_len][len_key + 1] = input[inp_byte]; dict[dict_len][0] = (unsigned char )(len_key + 1); // типа длинна в нулевом байте
            // key = input[inp_byte]
            ++dict_len;
            key[0] = input[inp_byte]; len_key = 1;
        }
    }
    if (size_inp > 0) {
        if ((res_len + 1) > mem_for_res) { // память под результат кончилась
            mem_for_res = mem_for_res + res_mem_step;
            res = realloc(res, mem_for_res * sizeof(unsigned int));
            if (res == NULL) {
                fprintf(stderr, "Memory allocation error\n");
                exit(1);
            }
        }
        // result.append(dictionary[w])
        res[res_len] = get_dict(dict, dict_len, key, len_key);
        ++res_len;
    }
    *result_len = res_len;
    for (unsigned int i = 0; i < dict_len; ++i) {
        free(dict[i]);
    } printf("\n");
    free(dict);
    free(key);
    return res;
}


int main() {
    unsigned long long int size;
    unsigned long long int len_result;
    // --------------------------
    FILE* file = fopen("2638.txt", "r");
    fseek(file, 0, SEEK_END);
    size = ftell(file);
    fseek(file, 0, SEEK_SET);
    unsigned char *input = malloc(size);
    fread(input, sizeof(char), size, file);
    fclose(file);
//    int ress[1052] = {77, 101, 109, 111, 114, 121, 32, 108, 101, 97, 107, 115, 32, 97, 114, 101, 268, 32, 99, 111, 109, 258, 110, 32, 101, 114, 114, 259, 32, 105, 278, 112, 282, 103, 114, 97, 276, 285, 103, 44, 279, 115, 112, 101, 99, 105, 97, 108, 108, 261, 119, 104, 101, 278, 117, 115, 293, 262, 97, 110, 103, 117, 97, 103, 101, 267, 116, 104, 97, 116, 32, 323, 118, 271, 110, 111, 32, 98, 117, 105, 108, 325, 285, 268, 117, 116, 275, 324, 105, 99, 32, 103, 269, 98, 318, 271, 274, 303, 299, 116, 105, 111, 110, 295, 115, 117, 99, 104, 268, 267, 67, 268, 110, 100, 32, 67, 43, 43, 46, 32, 84, 121, 112, 344, 302, 304, 295, 97, 32, 109, 257, 259, 261, 263, 265, 32, 111, 99, 99, 117, 114, 267, 98, 299, 97, 310, 271, 100, 121, 110, 291, 379, 303, 261, 380, 392, 324, 101, 369, 385, 258, 260, 326, 97, 397, 299, 275, 271, 117, 110, 270, 97, 362, 97, 98, 263, 374, 84, 307, 32, 287, 101, 118, 302, 308, 99, 271, 111, 102, 384, 386, 417, 389, 107, 332, 117, 103, 267, 323, 267, 263, 369, 341, 32, 322, 402, 437, 101, 108, 111, 112, 385, 110, 325, 443, 272, 110, 117, 109, 398, 114, 391, 444, 100, 101, 333, 103, 103, 312, 341, 111, 108, 321, 331, 479, 116, 354, 32, 424, 426, 428, 430, 271, 415, 387, 374, 66, 111, 424, 100, 115, 67, 307, 99, 107, 280, 295, 68, 463, 264, 510, 114, 295, 256, 416, 261, 86, 302, 105, 100, 324, 259, 295, 73, 66, 77, 32, 82, 343, 357, 302, 32, 80, 395, 105, 102, 121, 295, 522, 108, 289, 285, 100, 295, 80, 269, 419, 443, 325, 73, 110, 360, 270, 372, 512, 114, 374, 519, 387, 367, 414, 257, 119, 324, 362, 268, 270, 32, 115, 422, 477, 459, 434, 416, 271, 112, 465, 117, 108, 269, 445, 520, 32, 479, 481, 319, 396, 32, 102, 283, 366, 314, 369, 371, 43, 435, 288, 290, 109, 115, 374, 39, 67, 357, 115, 280, 438, 355, 328, 39, 346, 348, 350, 273, 486, 263, 99, 355, 357, 273, 97, 112, 429, 335, 105, 355, 320, 625, 278, 398, 268, 100, 479, 457, 331, 314, 261, 287, 111, 289, 291, 109, 312, 584, 315, 317, 319, 577, 324, 313, 509, 267, 630, 364, 272, 333, 335, 116, 45, 338, 102, 264, 116, 395, 101, 382, 368, 262, 105, 98, 290, 114, 105, 632, 594, 476, 100, 111, 484, 104, 105, 267, 269, 271, 97, 438, 335, 429, 263, 593, 595, 565, 370, 372, 601, 644, 603, 605, 32, 65, 619, 556, 611, 343, 328, 619, 353, 622, 283, 102, 547, 687, 672, 270, 99, 584, 105, 604, 384, 111, 115, 116, 295, 333, 325, 330, 325, 380, 295, 494, 264, 496, 694, 499, 260, 374, 65, 336, 104, 503, 103, 363, 460, 586, 564, 109, 314, 350, 476, 99, 314, 32, 719, 111, 328, 476, 735, 427, 323, 497, 749, 260, 295, 658, 755, 110, 731, 593, 270, 498, 446, 261, 322, 654, 686, 573, 355, 303, 757, 736, 764, 694, 597, 577, 280, 101, 680, 580, 111, 491, 468, 301, 408, 781, 335, 108, 493, 610, 102, 583, 562, 111, 479, 114, 278, 739, 261, 751, 405, 591, 321, 307, 270, 792, 700, 118, 524, 271, 491, 362, 110, 105, 113, 117, 679, 283, 643, 645, 276, 280, 488, 573, 257, 314, 355, 755, 798, 751, 114, 449, 811, 32, 119, 630, 363, 438, 260, 648, 462, 487, 576, 401, 804, 108, 110, 320, 115, 295, 306, 344, 363, 274, 281, 320, 581, 672, 458, 851, 121, 853, 328, 855, 470, 495, 764, 629, 116, 121, 432, 578, 776, 384, 752, 591, 588, 111, 632, 772, 102, 774, 367, 391, 98, 106, 492, 778, 337, 267, 726, 282, 315, 304, 784, 763, 693, 101, 741, 278, 111, 898, 492, 780, 904, 357, 103, 907, 879, 910, 284, 444, 658, 780, 922, 765, 101, 849, 280, 588, 105, 719, 116, 907, 98, 409, 781, 905, 103, 784, 666, 270, 110, 441, 391, 476, 547, 934, 354, 937, 939, 428, 338, 470, 918, 315, 943, 790, 946, 320, 374, 40, 705, 958, 942, 818, 961, 947, 780, 383, 969, 945, 947, 901, 734, 110, 108, 105, 510, 272, 119, 515, 960, 975, 670, 601, 462, 468, 717, 897, 899, 622, 773, 275, 332, 930, 959, 347, 114, 349, 652, 352, 621, 491, 100, 46, 41, 375, 331, 436, 328, 468, 577, 686, 295, 748, 479, 876, 465, 932, 927, 869, 609, 674, 694, 680, 273, 389, 826, 959, 117, 112, 986, 440, 632, 97, 102, 491, 761, 610, 1018, 377, 407, 953, 837, 116, 355, 959, 748, 974, 1037, 459, 331, 472, 783, 357, 971, 902, 32, 330, 262, 919, 932, 860, 413, 413, 565, 768, 444, 860, 441, 115, 115, 269, 542, 332, 261, 808, 101, 483, 726, 280, 312, 641, 279, 1014, 325, 980, 1084, 860, 592, 901, 887, 285, 116, 97, 338, 967, 1036, 962, 836, 748, 914, 994, 116, 374, 555, 346, 308, 280, 302, 382, 340, 342, 840, 766, 812, 888, 257, 308, 1061, 579, 757, 914, 310, 732, 672, 274, 110, 1014, 678, 1015, 1029, 1020, 463, 1022, 396, 382, 816, 101, 1080, 1056, 794, 1062, 101, 1069, 458, 722, 112, 263, 467, 325, 894, 1148, 312, 282, 340, 285, 632, 283, 119, 259, 417, 429, 503, 325, 748, 610, 828, 1054, 338, 864, 570, 720, 264, 472, 1035, 780, 298, 114, 680, 385, 369, 283, 635, 1131, 441, 809, 1069, 1167, 340, 847, 307, 460, 476, 283, 772, 756, 1106, 916, 903, 782, 801, 1053, 962, 1008, 32, 73, 1061, 264, 311, 932, 1029, 383, 832, 603, 385, 476, 458, 107, 330, 119, 1195, 308, 272, 1207, 971, 267, 1063, 464, 315, 1066, 1148, 638, 653, 278, 1222, 1224, 1226, 278, 1201, 915, 995, 780, 1232, 1065, 476, 1229, 413, 374, 72, 111, 984, 760, 1115, 341, 751, 1118, 846, 813, 350, 1154, 633, 284, 109, 581, 610, 272, 1182, 1184, 314, 947, 759, 280, 307, 97, 548, 697, 658, 682, 892, 1146, 463, 722, 285, 412, 268, 1058, 444, 748, 1218, 646, 312, 280, 282, 1094, 323, 325, 755, 401, 1119, 262, 515, 605};
// --------------------------
//    printf("%s\n", input);
    unsigned int *result = lzw_encode(input, size, &len_result);
//    for (unsigned int i = 0; i < len_result; ++i) {
//        if (result[i]!= ress[i]) {
//            printf("\nerror\n");
//            return 666;
//            break;
//        }
//        printf("%d ", result[i]);
//    } printf("\n");
//    for (int i = 0; i < len_result; ++i) {
//        printf("%d, ", result[i]);
//    }
    printf("Длинна исходной(байт): %llu. Длинна сжатой('чисел'): %llu\n", size, len_result);
    free(result);
    return 0;
}




// 11.02 -- 90!
// 12.02 -- 160! рабочий алгоритм кодирования LZW на вложенном массиве (22336391857 инструкций; 1,85 мб; 2.16 с; 2638.txt; Исходно байт: 50656; Выход байт: [14533*2])
